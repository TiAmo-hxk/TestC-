#include <iostream>
#include <cstring>
#include <string>

// 将两个字符串反转，从低位到高位进行相加。
// 用一个变量carry来记录进位，初始为0。
// 从两个字符串的第0位开始，逐位相加，并加上carry。
// 将相加的结果对10取余，作为当前位的和，并将其添加到一个新的字符串中。
// 将相加的结果除以10，作为下一位的进位。
// 重复步骤3-5，直到两个字符串都遍历完或者carry为0。
// 将最后得到的字符串反转，即为最终答案。
// 代码如下：

class Solution {
public:
    string addStrings(string num1, string num2) {
        // 反转两个字符串
        reverse(num1.begin(), num1.end());
        reverse(num2.begin(), num2.end());
        // 初始化进位为0
        int carry = 0;
        // 初始化结果为空字符串
        string ans = "";
        // 遍历两个字符串
        for (int i = 0; i < max(num1.size(), num2.size()); i++) {
            // 如果当前位置有数字，则取出对应的数字值，否则为0
            int a = i < num1.size() ? (num1[i] - '0') : 0;
            int b = i < num2.size() ? (num2[i] - '0') : 0;
            // 计算当前位置的和
            int sum = a + b + carry;
            // 计算当前位置的余数，并将其添加到结果中
            ans += (sum % 10 + '0');
            // 计算下一位置的进位
            carry = sum / 10;
        }
        // 如果最后还有进位，则添加到结果中
        if (carry) {
            ans += (carry + '0');
        }
        // 反转结果并返回
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
// 代码详细讲解：

// 首先定义一个类Solution，其中有一个公共成员函数addStrings，接受两个string类型的参数num1和num2，并返回一个string类型的值。
// 在函数内部，我们首先使用reverse函数（需要#include <algorithm>）来反转两个输入字符串。这样做是为了方便从低位到高位进行相加操作。
// 然后我们定义一个整型变量carry来存储进位信息。初始时carry为0，表示没有进位。
// 接着我们定义一个空字符串ans来存储最终答案。注意这里使用了string类提供的默认构造函数来创建空字符串对象。
// 接下来我们使用一个for循环来遍历两个输入字符串。循环条件是i小于num1和num2中较长者的长度。循环变量i表示当前处理的位置索引（从右向左）。
// 在循环体内部，我们首先判断当前位置是否有数字存在。如果有，则使用字符减去’0’（即48）来得到对应的数字值；如果没有，则默认为0。这样我们就得到了a和b分别表示num1和num2在当前位置上的数字值。
// 然后我们计算当前位置上两个数字以及进位之和sum。这里使用了简单的加法运算符+来实现。
// 接着我们计算当前位置上相加后剩余部分rem，并将其转换成字符（即加上’0’或48）并添加到ans末尾




// 遍历两个链表，逐位相加对应的数字。
// 如果其中一个链表已经到达末尾，则将其对应的数字视为0。
// 直到两个链表都到达末尾或者进位为0为止。
// 如果两位相加的结果大于9，则设置进位为1，并将当前位的结果减去10。
// 代码如下：

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // 初始化结果为空链表
        ListNode* ans = NULL;
        // 初始化当前节点和前一个节点为空指针
        ListNode* curr = NULL;
        ListNode* prev = NULL;
        // 初始化进位为0
        int carry = 0;
        // 遍历两个链表
        while (l1 || l2) {
            // 如果当前位置有数字，则取出对应的数字值，否则为0
            int a = l1 ? l1->val : 0;
            int b = l2 ? l2->val : 0;
            // 计算当前位置的和
            int sum = a + b + carry;
            // 计算当前位置的余数，并创建一个新节点存储它
            int rem = sum % 10;
            ListNode* node = new ListNode(rem);
            // 如果结果为空链表，则将其指向新节点
            if (!ans) {
                ans = node;
            }
            // 如果前一个节点不为空，则将其指向新节点
            if (prev) {
                prev->next = node;
            }
            // 更新当前节点和前一个节点
            curr = node;
            prev = curr;
            // 计算下一位置的进位
			carry = sum / 10;
            // 如果当前位置有数字，则移动到下一个节点
            if (l1) {
                l1 = l1->next;
            }
            if (l2) {
                l2 = l2->next;
            }
        }
        // 如果最后还有进位，则创建一个新节点存储它，并将前一个节点指向它
        if (carry) {
            ListNode* node = new ListNode(carry);
            prev->next = node;
        }
        // 返回结果链表
        return ans;
    }
};
// 代码详细讲解：

// 首先定义一个类Solution，其中有一个公共成员函数addTwoNumbers，接受两个ListNode类型的指针参数l1和l2，并返回一个ListNode类型的指针值。
// 在函数内部，我们首先定义一个空链表ans来存储最终答案。注意这里使用了ListNode类提供的默认构造函数来创建空链表对象。
// 然后我们定义两个ListNode类型的指针变量curr和prev来表示当前节点和前一个节点。初始时curr和prev都为NULL，表示没有任何节点。
// 接着我们定义一个整型变量carry来存储进位信息。初始时carry为0，表示没有进位。
// 接下来我们使用一个while循环来遍历两个输入链表。循环条件是l1或者l2不为空指针。循环变量无需定义，因为我们直接使用l1和l2作为遍历指针。
// 在循环体内部，我们首先判断当前位置是否有数字存在。如果有，则直接取出对应的数字值；如果没有，则默认为0。这样我们就得到了a和b分别表示l1和l2在当前位置上的数字值。
// 然后我们计算当前位置上两个数字以及进位之和sum。这里使用了简单的加法运算符+来实现。
// 接着我们计算当前位置上相加后剩余部分rem，并使用new运算符（需要#include <new>）来动态分配内存空间，并调用ListNode类提供的带参数构造函数来创建一个新节点node并初始化其值为rem。
// 如果结果链表ans为空链表，则将其指向新节点node。这样做是为了确保结果链表始终有头结点。
// 如果前一个节点prev不为空指针，则将其next成员变量指向新节点node。这样做是为了确保结果链表始终连贯无断裂。
// 更新当前节点curr和前一个节点prev，使它们都指向新节点node。这样做是为了准备下一次循环时添加新节点到结果链表末尾。
// 计算下一位置的进位carry，即sum除以10得到的商。这里使用了整除运算符/来实现









// 首先检查字符串是否为空或者第一个字符是否为’0’，如果是，则返回0。
// 然后初始化两个变量dp[0]和dp1为1，分别表示空字符串和单个字符的解码方式数。
// 接着从第二个字符开始，对每个字符s[i]，检查它是否可以单独解码或者与前一个字符组合解码。
// 如果s[i]不为’0’，则它可以单独解码为一个字母，因此dp[i+1] += dp[i]。
// 如果s[i-1]和s[i]组合起来在"10"到"26"之间，则它们可以组合解码为一个字母，因此dp[i+1] += dp[i-1]。
// 最后返回dp[n]，其中n是字符串的长度。
// 代码如下：

class Solution {
public:
    int numDecodings(string s) {
        // 如果字符串为空或者第一个字符为'0'，则返回0
        if (s.empty() || s[0] == '0') return 0;
        // 获取字符串长度
        int n = s.size();
        // 定义动态规划数组
        vector<int> dp(n + 1);
        // 初始化空字符串和单个字符的解码方式数
		dp[0] = 1;
        dp[1] = 1;
        // 遍历字符串
        for (int i = 1; i < n; i++) {
            // 如果当前字符不为'0'，则可以单独解码
            if (s[i] != '0') {
                dp[i + 1] += dp[i];
            }
            // 如果前一个字符和当前字符组合在"10"到"26"之间，则可以组合解码
            if (s[i - 1] == '1' || (s[i - 1] == '2' && s[i] <= '6')) {
                dp[i + 1] += dp[i - 1];
            }
        }
        // 返回最终结果
        return dp[n];
    }
};
// 代码详细讲解：

// 首先定义一个类Solution，其中有一个公共成员函数numDecodings，接受一个string类型的参数s，并返回一个int类型的值。
// 在函数内部，我们首先判断字符串是否为空或者第一个字符是否为’0’。如果是，则直接返回0，表示没有任何解码方式。这里使用了逻辑或运算符||来实现。
// 然后我们获取字符串的长度n，并使用size()成员函数来实现。
// 接着我们定义一个动态规划数组dp，并使用vector<int>类型来实现。这个数组的大小为n+1，表示从空字符串到整个字符串的每个子串的解码方式数。
// 接下来我们初始化dp[0]和dp[1]为1，分别表示空字符串和单个字符的解码方式数。注意这里假设输入字符串不包含非法字符（即不在"0"到"9"之间）。
// 然后我们使用一个for循环来遍历字符串。循环变量为i，从第二个字符开始（即索引为1），直到最后一个字符结束（即索引为n-1）。循环步长为1。
// 在循环体内部，我们首先判断当前字符s[i]是否不为’0’。如果是，则说明它可以单独解码为一个字母（即’A’到’I’之间）。因此dp[i+1]加上dp[i]，表示当前子串的解码方式数等于前面子串的解码方式数加上当前字符单独解码的一种方式。这里使用了赋值加运算符+=来实现。


using OpsCallback = std::function<int(const std::string&)>;
